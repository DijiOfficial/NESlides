;===================================================================================================
; NMI (Non-Maskable Interrupt) is triggered by vertical blanking, used for rendering and updates.
;===================================================================================================

; 7  bit  0
; ---- ----
; VPHB SINN
; |||| ||||
; |||| ||++- Base nametable address
; |||| ||    (0 = $2000; 1 = $2400; 2 = $2800; 3 = $2C00)
; |||| |+--- VRAM address increment per CPU read/write of PPUDATA
; |||| |     (0: add 1, going across; 1: add 32, going down)
; |||| +---- Sprite pattern table address for 8x8 sprites
; ||||       (0: $0000; 1: $1000; ignored in 8x16 mode)
; |||+------ Background pattern table address (0: $0000; 1: $1000)
; ||+------- Sprite size (0: 8x8 pixels; 1: 8x16 pixels â€“ see PPU OAM#Byte 1)
; |+-------- PPU master/slave select
; |          (0: read backdrop from EXT pins; 1: output color on EXT pins)
; +--------- Vblank NMI enable (0: off, 1: on)

.proc nmi
	; Save the registers
	pha
	txa
	pha
	tya
	pha
	php

	; Check whether we're ready to render, skip to end if not
	lda var_nmi_ready
	beq end
    
;===================================================================================================

    ; Increase the frame count and cap it at 50
	inc var_frame_count		 			
	jsr frame_count_cap

    ; Check the background collision
	jsr check_background_collision

    jsr update_background_color

;===================================================================================================
    
	; Transfer the local OAM data into the PPU
	jsr transfer_oam

	; Reset the scroll (https://www.nesdev.org/wiki/PPU_scrolling#:~:text=Set%20the%20scroll%20last,overwrite%20the%20scroll%20position.)
	lda #$00
	sta PPU_SCROLL
	sta PPU_SCROLL
    
	ldx #NMI_SIG_CLEAR
	stx var_nmi_ready

end:
	; pop registers
	plp
	pla
	tay
	pla
	tax
	pla
	rti
.endproc

.proc frame_count_cap
	lda var_frame_count
	cmp #50
	bne @return

	lda #0
	sta var_frame_count

@return:
	rts
.endproc

.proc update_background_color
    SET_PPU_ADDRESS NT1_ATTR           ; Set the PPU address to the attribute table of the first nametable
    ldx #64                            ; 64 bytes to update
    ldy #0                             ; Index for the attribute table
    CONDITIONAL_LOAD var_current_bg_state, 0, var_current_bg_color, 0    ; 0   = $00
    CONDITIONAL_LOAD var_current_bg_state, 1, var_current_bg_color, 85   ; 85  = $55
    CONDITIONAL_LOAD var_current_bg_state, 2, var_current_bg_color, 170  ; 170 = $AA
    CONDITIONAL_LOAD var_current_bg_state, 3, var_current_bg_color, 255  ; 255 = $FF
    lda var_current_bg_color           ; Load the color to write to the attribute table
:
    sta PPU_DATA                       ; Write the color to the attribute table
    iny                                ; Increment the index
    dex                                ; Decrement the counter
    bne :-                             ; Loop until all 64 bytes are updated

    rts
.endproc

.proc transfer_oam
    ; Set the starting address to write to in the PPUs OAM
    lda #$00
    sta OAM_ADDRESS
   
    lda #>oam           ; Load the high byte of the local OAM's address
    sta OAM_DMA      ; Set the high byte of the local OAM's address in the OAM_DMA, effectively triggering the DMA

    rts
.endproc