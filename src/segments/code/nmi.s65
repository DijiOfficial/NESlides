;===================================================================================================
; NMI (Non-Maskable Interrupt) is triggered by vertical blanking, used for rendering and updates.
;===================================================================================================

; 7  bit  0
; ---- ----
; VPHB SINN
; |||| ||||
; |||| ||++- Base nametable address
; |||| ||    (0 = $2000; 1 = $2400; 2 = $2800; 3 = $2C00)
; |||| |+--- VRAM address increment per CPU read/write of PPUDATA
; |||| |     (0: add 1, going across; 1: add 32, going down)
; |||| +---- Sprite pattern table address for 8x8 sprites
; ||||       (0: $0000; 1: $1000; ignored in 8x16 mode)
; |||+------ Background pattern table address (0: $0000; 1: $1000)
; ||+------- Sprite size (0: 8x8 pixels; 1: 8x16 pixels â€“ see PPU OAM#Byte 1)
; |+-------- PPU master/slave select
; |          (0: read backdrop from EXT pins; 1: output color on EXT pins)
; +--------- Vblank NMI enable (0: off, 1: on)

.proc nmi
	; Save the registers
	pha
	txa
	pha
	tya
	pha
	php

	; Check whether we're ready to render, skip to end if not
	lda var_nmi_ready
	beq end
    
;===================================================================================================

    ; Increase the frame count and cap it at 50
	inc var_frame_count		 			
	jsr frame_count_cap

    ; Check the background collision
	jsr check_background_collision

;===================================================================================================

.if DEBUG
    DEBUG_NMI
.endif

;===================================================================================================
    
	; Transfer the local OAM data into the PPU
	jsr transfer_oam

	; Reset the scroll (https://www.nesdev.org/wiki/PPU_scrolling#:~:text=Set%20the%20scroll%20last,overwrite%20the%20scroll%20position.)
	lda #$00
	sta PPU_SCROLL
	sta PPU_SCROLL

	ldx #NMI_SIG_CLEAR
	stx var_nmi_ready
	jmp end

end:
	; pop registers
	plp
	pla
	tay
	pla
	tax
	pla
	rti
.endproc

.proc frame_count_cap
    @fps = 50
	lda var_frame_count
	cmp #@fps
	bne @return

	lda #0
	sta var_frame_count

@return:
	rts
.endproc

.proc update_background_color
    @attr_count = 64
	@start_index = 0
	@color_palette_1 = 0   ; $00
	@color_palette_2 = 85  ; $55
	@color_palette_3 = 170 ; $AA
	@color_palette_4 = 255 ; FF
	
    SET_PPU_ADDRESS NT1_ATTR           ; Set the PPU address to the attribute table of the first nametable
    ldx #@attr_count                            ; 64 bytes to update
    ldy #@start_index                             ; Index for the attribute table
    CONDITIONAL_LOAD var_current_bg_state, 0, var_current_bg_color, @color_palette_1
    CONDITIONAL_LOAD var_current_bg_state, 1, var_current_bg_color, @color_palette_2
    CONDITIONAL_LOAD var_current_bg_state, 2, var_current_bg_color, @color_palette_3
    CONDITIONAL_LOAD var_current_bg_state, 3, var_current_bg_color, @color_palette_4
    lda var_current_bg_color           ; Load the color to write to the attribute table
:
    sta PPU_DATA                       ; Write the color to the attribute table
    iny                                ; Increment the index
    dex                                ; Decrement the counter
    bne :-                             ; Loop until all 64 bytes are updated

    rts
.endproc

.proc transfer_oam
    ; Set the starting address to write to in the PPUs OAM
    lda #$00
    sta OAM_ADDRESS
   
    lda #>oam           ; Load the high byte of the local OAM's address
    sta OAM_DMA      ; Set the high byte of the local OAM's address in the OAM_DMA, effectively triggering the DMA

    rts
.endproc