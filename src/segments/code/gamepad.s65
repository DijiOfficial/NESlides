;===================================================================================================
; Polls gamepad input, updates button state and tracks released buttons 
; The controller inputs are read from the data bus in reverse order, making bit 0 (A) stored as bit 7.
; https://www.nesdev.org/wiki/Standard_controller
; https://www.nesdev.org/wiki/Controller_reading_code
;===================================================================================================
.proc gamepad_poll
	lda var_gamepad                    ; Load current state of var_gamepad to check button press/released
	pha                                ; Push it on the stack

	lda #1                             ; A = 1
    sta var_gamepad                    ; var_gamepad = 1

    ;===================================================================================================
	; strobe the gamepad to latch current button state
    ; This means that reading from JOYPAD1 will only return the state of the first button: button A.
    ; By storing 0 into JOYPAD1, the strobe bit is cleared and the reloading stops.
    ; This allows all 8 buttons (newly reloaded) to be read from JOYPAD1.
    ;===================================================================================================
	sta JOYPAD1                        ; Write 1 to JOYPAD1
	lsr                                ; A = 0 (00000001 >> 00000000), carry flag = 1
	sta JOYPAD1                        ; Write 0 to JOYPAD1

loop:
	lda JOYPAD1                        ; Get the value of the current button we're checking
    lsr                                ; Shift the bits to the right, current button (LSB) is now in the carry flag, and bit 7 is 1 after the first shift
    rol var_gamepad                    ; Rotate the carry flag (current button) into the var_gamepad
	bcc loop                           ; If the carry flag is 1, we're done reading all buttons

	pla                                ; Load values of var_gamepad from previous frame
	sta temp_00                        ; temp storage
	eor var_gamepad                    ; old_gamepad XOR var_gamepad
	and temp_00                        ; (old_gamepad XOR var_gamepad) AND old_gamepad
	sta var_gamepad_released           ; Store the released buttons

	rts                                ; return
.endproc

;===================================================================================================
; Subroutine to handle player inputs.
;===================================================================================================
.proc handle_player_input
	jmp @begin							; Jump ahead, there's a lot of code int this function so there are two returns in this function
@menu_input:
    ON_BUTTON_RELEASE PAD_U, MOVE_ARROW_UP
    ON_BUTTON_RELEASE PAD_D, MOVE_ARROW_DOWN

	ON_BUTTON_RELEASE PAD_SELECT, SELECT_MODE
@return:
	rts

@begin:
	lda var_gamestate					; First check gamestate
	beq @menu_input						; If its menu go to menu input and return

	jmp @not_menu_controls				; If it's slides go to the other checks
@not_fun_controls:
	ON_BUTTON_RELEASE PAD_R, LOAD_NEXT_SLIDE
	ON_BUTTON_RELEASE PAD_L, LOAD_PREVIOUS_SLIDE

	jmp @return

@not_menu_controls:
	lda var_bools						;
	and #%00000010						; Now Check if we are in fun mode or not
	beq @not_fun_controls				; If not go back to not fun controls

; Handle shooting and Player Movement
    ON_BUTTON_RELEASE PAD_A, SHOOT_BULLET

    ON_BUTTON_PRESS PAD_U, MOVE_UP
    ON_BUTTON_PRESS PAD_D, MOVE_DOWN
    ON_BUTTON_PRESS PAD_L, MOVE_LEFT
    ON_BUTTON_PRESS PAD_R, MOVE_RIGHT

	ON_BUTTON_RELEASE PAD_START, LOAD_NEXT_SLIDE
	ON_BUTTON_RELEASE PAD_SELECT, LOAD_PREVIOUS_SLIDE


@return:
    rts
.endproc