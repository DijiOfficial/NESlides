;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Sprite Attribute Byte:
;-----------------------
; 76543210
; |||   ||
; |||   ++- Color Palette of sprite. Choose which set of 4 from the 16 colors to use
; |||
; ||+------ Priority (0: in front of background; 1: behind background)
; |+------- Flip sprite horizontally
; +-------- Flip sprite vertically

bullet_data:
;      Y   tile#   attribs     X
.byte $F0,  $04,  %00000000,  $50           ; OAM sprite 1 at (x: 16, y: 16)

;; TODO SET UP VARIABLES FOR THE POSITIONS

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Subroutine to load Bullet Sprites into OAM-RAM starting at $0200, the function will load one sprite then loop back to load the next one until 6 bullets are loaded in OAM
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.proc load_bullets
    ldx #0                                  ; Reset X
	ldy #0                                  ; Reset Y
loop_sprite:
    lda bullet_data,x                       ; We fetch bytes from the SpriteData lookup table
    sta temp_8_bit_holder                   ; Store the value for now
    stx temp_byte                           ; Store X
    txa                                     ;
    pha                                     ; Push A on stack
    tya                                     ; 
    pha                                     ; Push Y on stack
; we now want to calculate the position of the sprite x = x + y * 4
    lda #00                                 ; Clear A
	cpy #00                                 ; if Y == 0
	beq :+                                  ; Don't multiply
multiply_loop:                              ; Else loop multiply
    clc                                     ; Clear Carry
	adc #4                                  ; Add 4
	dey                                     ; --Y    
	beq:+                                   ; if Y == 0 we're done
	jmp multiply_loop
:
    clc                                     ; Clear Carry
    adc temp_byte                           ; Add X back to Y * 4
    tax                                     ; Assign X + Y * 4 back to X => X = X + Y * 4

    pla                                     ;
    tay                                     ; Restore Y

    lda temp_8_bit_holder                   ; Reload the value we want to store
    sta $0200,x                             ; We store the bytes starting at OAM address $0200 with offset X

    PLA                                     ; 
    TAX                                     ; Restore X

    inx                                     ; ++x
    cpx #4                                  ; X == 4?
    bne loop_sprite                         ; Loop 4 times (1 hardware sprite, 4 bytes each)
    ldx #0                                  ; Reset X
	iny                                     ; ++y
    cpy #6                                  ; Y == 6? How many times we want to repeat this copy
	bne load_bullets::loop_sprite
    rts                                     ; return
.endproc

; this code currently only moves the first sprite in the oam. Since there's only one sprite its fine for now but will need to either keep track of which sprite is where if we add more
.proc move_bullet 
    lda bullet_info                          ; Load the current bullet_info byte
    and #%11111100                           ; Clear bits 0 and 1 for idle state default
    sta bullet_info                          ; Store the updated value back to bullet_info

    ON_BUTTON_PRESSED PAD_L, MOVE_LEFT
    ON_BUTTON_PRESSED PAD_R, MOVE_RIGHT
    ON_BUTTON_PRESSED PAD_U, MOVE_UP
    ON_BUTTON_PRESSED PAD_D, MOVE_DOWN

    ON_BUTTON_RELEASED PAD_A, SHOOT_BULLET

    rts                                      ; return
.endproc

.proc find_bg_tile_position
; Step 1: Calculate column index
    lda oam + 3                             ; Get X position of first sprite
    lsr a                                   ; Divide by 2 (shift right once)
    lsr a                                   ; Divide by 4
    lsr a                                   ; Divide by 8 (now A = column index)
	sta temp_byte                           ; Temporarily store the column index for addition later

	; Check if the sprite movement is right or left, if so we want to add or remove one to the tile position we want
	lda bullet_info                         ; Load the sprite info
    and #%00000011                          ; Mask out all but the two LSBs
    cmp #%00000001                          ; Check if the two LSBs are 01 (RIGHT)
    beq add_one                             ; If so, jump to add one to X
    cmp #%00000011                          ; Check if the two LSBs are 11 (LEFT)
    beq subtract_one                        ; If so, jump to subtract one to X
    jmp skip                                ; Otherwise, skip adjustment
add_one:
    inc temp_byte                           ; ++X
    jmp skip                                ; Skip over
subtract_one:
    dec temp_byte                           ; --X
skip:

; Step 2: Calculate row index
    lda oam                                 ; Get Y position of first sprite
    lsr a                                   ; Divide by 2 (shift right once)
    lsr a                                   ; Divide by 4
    lsr a                                   ; Divide by 8 (now A = row index)
    tay                                     ; Transfer to Y for later multiplication
                
	lda bullet_info                         ; Load the sprite info
    and #%00000011                          ; Mask out all but the two LSBs
    cmp #%00000010                          ; Check if the two LSBs are 01 (DOWN)
    beq add_to_Y                            ; If so, jump to add one to Y
    cmp #%00000000                          ; Check if the two LSBs are 11 (UP)
    beq subtract_from_Y                     ; If so, jump to subtract one to Y
    jmp end                                 ; Otherwise, skip adjustment
add_to_Y:
    iny                                     ; ++Y
    jmp end                                 ; Skip over
subtract_from_Y:
    dey                                     ; --Y
end: ; Need to check for edge cases, currently it's wrapping around

; Step 3: Compute tile position = row (Y) Ã— 32 + column (temp_byte)
    ldx #$20                                ; Clear X (setting it to nametable high byte location)
    lda #00                                 ; Clear A
	cpy #00                                 ; if Y == 0
	beq :+                                  ; Don't multiply
multiply_loop:                              ; Else loop multiply
    clc                                     ; Clear Carry
	adc #32                                 ; Add 32
	bne :+                                  ; Check if zero flag is set
    inx                                     ; ++X
	:
	dey                                     ; --Y    
	beq:+                                   ; if Y == 0 we're done
	jmp find_bg_tile_position::multiply_loop
:

    clc                                     ; Clear Carry
	adc temp_byte                           ; Add X (temp_byte)
	;; TODO add to X the correct nametable location, currently defaulting to $2000
	stx background_tile_ptr                 ; store X as the highbyte of the ptr
	sta background_tile_ptr + 1             ; Store A as the lowbyte of the ptr
	; tax                                     ; Store result in X

  rts                                       ; return
.endproc

;; Can reuse this for transitions
; .proc clear_background_tile
; ; Define the target nametable address
;     lda background_tile_ptr                 ; High byte of the address
;     sta PPU_VRAM_ADDRESS2                   ; Write high byte to PPU_ADDRESS
;     lda background_tile_ptr+1               ; Low byte of the address
;     sta PPU_VRAM_ADDRESS2                   ; Write low byte to PPU_ADDRESS

; ; Write the tile index (e.g., tile $03)
;     lda #$00              ; Tile index to write
;     sta PPU_VRAM_IO                         ; Write to PPU_DATA

; 	rts
; .endproc

; .proc update_bullets
;     ldx #01
;     lda oam                              ; Get current Y of the first sprite      
;     cmp #0                               ; Check if Y is already 0
;     beq NOT_GAMEPAD_UP                   ; If so don't move up
;     sec                                  ; Set carry   
;     sbc #1                               ; Substract 1
;     sta oam                              ; Store Y - 1 to Y

;     lda bullet_info                      ; Load the current bullet_info byte
;     and #%11111100                       ; Clear bits 0 and 1 
;     ; ora #%00000000                     ; Don't need to combine Up is 00
;     sta bullet_info                      ; Store the updated value back to bullet_info
; .endproc

.proc clear_background_tile
; Define the target nametable address
    lda background_tile_ptr                 ; High byte of the address
    sta PPU_VRAM_ADDRESS2                   ; Write high byte to PPU_ADDRESS
    lda background_tile_ptr+1               ; Low byte of the address
    sta PPU_VRAM_ADDRESS2                   ; Write low byte to PPU_ADDRESS

; Write the tile index (e.g., tile $03)
    lda #$00              ; Tile index to write
    sta PPU_VRAM_IO                         ; Write to PPU_DATA

	rts
.endproc